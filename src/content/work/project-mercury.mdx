---
title: Project Mercury
publishDate: 2020-03-04 00:00:00
img: /assets/project-mercury/splash.png
img_alt: The rooftop of a parking garage in a futuristic cyberpunk city
description: |
  A movement-based first-person shooter that places you in the shoes of a lone operative fighting hordes of robots in an urban cyberpunk future
tags:
  - First Person Shooter
  - Unreal Engine

---
import Grid from '../../components/Grid.astro'

### Overview
Project Mercury was developed by a team of 14 people over the course of one college semester. The goal of the game was to create a fast-paced first person shooter game that would allow us to gain experience working with Unreal Engine 5. We were inspired by games like Titanfall 2, Mirror's Edge, and Ghostrunner, and decided to create a game particulary inspired by the technical movement mechanics present in those titles. Project Mercury is an adreneline-inducing mix of run and gun action against the backdrop of the rainy neo-futuristic late 21st century Detroit skyline. 

### Technical Contributions
I worked as a general programmer for Project Mecury, but mainly worked on systems programming or lower level components written in C++. My contributions include:
 - A robust, complete, and polished character controller. Since a main focus of our game's identity and feel was the presence of an intuitive and polished movement system, I was entrusted to develop, implement, and iterate on our first person character controller. Over the development cycle, this was my most important task.

    &nbsp; 
    &nbsp; 
 - A reusable and extensible throwable items system, used for the 4 different types of grenades in Project Mercury; two for the player's use, and two for the enemies'.

    &nbsp; 
    &nbsp; 
 - A complete and polished special skill, inspired by the Deadeye ability from Read Dead Redemption 2 and Cassidy's High Noon Ultimate from Overwatch. This is accompanied by a reactive points system that tracks and charges up based on the player's ability to maintain their momentum through the level.

And several other miscellaneous tasks.


#### Advanced Movement
In a first person game, the character controller is an oft overlooked factor in the overall feeling of fun and polish apparent to players. It affects nearly every single interaction they have whilst playing, yet a good first-person controller should be as intuitive as possible, and far from the front of the player's mind. If the player notices the controller, it's likely because it behaved in way that was not intended by their inputs. This only serves to interrupt their immersion and flow, and is a trademark of poorly programmed games.

##### Reverse Engineering
In order to develop an excellent movement component, we looked towards a game with one of the most loved movements systems - Titanfall 2.
My work on the character controller for this game could be summarized as trying to reverse engineer what made Titanfall's movement so fluid and addicting.

This was an ongoing process, but I learned so much about how the creators of that game implemented their iconic parkour system, and I took what I learned to create a stripped-down and simplified, but still fun, version into our game.

##### Features


##### Wall Running
The most important aspect of the movement system in Project Mercury is the wallrunning. It's logic begins here:
![](/assets/project-mercury/UpdateCharacterStateBeforeMovement.png)
The base class implementation of the CharacterMovementComponent executes this function at the end of every frame to see if the current movement mode has changed. If the character is falling, and the the `CanWallRun` function returns true, the state is changed to initiate a wallrun.
![](/assets/project-mercury/OnMovementModeChanged.png)
Another funtion that is executed every frame, `OnMovementModeChanged`, then runs the `OnEnterWallRun` function. Notice also how when the state changes away from `CMoveWallRun`, the `OnExitWallRun` function will likewise be called.
![](/assets/project-mercury/OnEnterWallRun.png)
![](/assets/project-mercury/OnExitWallRun.png)
This architecture ensures that the state of the system is properly managed. Any code that needs to be executed at the start or end of a movement mode can be placed here, and it will run, regardless of how many possible places the movement mode could begin or be cancelled at.
Continuing on with the code, the base class executes the `PhysCustom` function due to being in a derived class movement mode. The override `PhysCustom` then just needs to forward to a dedicated `Phys*` function depending on the specific movement mode.
![](/assets/project-mercury/PhysCustom.png)
At long last, the code finally reaches the code that actually wallruns the player, `PhysWallRun`.
The function itself is long, so only the important sections are shown here.
![](/assets/project-mercury/PhysWallRun_Break.png)
Firstly, the code re-checks that the conditions for starting a wall-run are still being met. It also checks here to see how long has elapsed since the wallrun started, and exits the move mode if the allotted wall run time has expired;
![](/assets/project-mercury/PhysWallRun_PlaneProject.png)
Then, the player's acecleration and velocity are projected onto the plane of the wall. This is what sticks the player to wall so they don't come off of it unless they indend to.
Here is also shown how the gravity is applied based on the altitude of the player's view direction. That is, they'll continue moving at the same height on the wall, unless they look downwards. This prevents the very unituitive situation where the player is looking down and holding the forward input, but moves upwards relative to the camera.
![](/assets/project-mercury/PhysWallRun_Rotate.png)
Another nice feature of this wallrunning implementation is that the player is gently rotated while running, such that their look direction stays the same relative to the part of the wall they're currently contacting. This removes the need to move the look input while running around a curved wall, and creates the feeling of being carried around the turn by the wall.
![](/assets/project-mercury/PhysWallRun_Apply.png)
The actual movement portion of this movement mode is very succint. Other than some minor checks and safe-guards, the player is moved by their velocity in the direction of their acceleration (which are now both clamped to be in the plane of the wall) and one additional stick force is applied into the wall. This is to ensure contact with the wall remains even when running a sharp concave surface.
Lastly, one of the more important parts of this system to recreating the feel of Titanfall 2 is the specific conditions that must be met and/or remain met in order to wall run.
![](/assets/project-mercury/CanWallRun.png)
The `CanWallRun` function is responsible for checking the current state, and determining whether a wall run can be started. It ensures that the player is not on the ground and falling down. It then forwards the check to see if the player is up against a suitable wall to the `CheckForWall` function, which returns a UE5 `FHitResult` struct with all of the information of the best successful raycast for a wall.
It then completes the same logic as Titanfall does to prevent increasing height on the same wall; A change in the wall ran on (approximated by a large change in normal as compared to the last surface the player wall ran on), seeing if enough time has passed since running on this wall, or seeing that the height is lower than previously ran on. This allows for wall running and gaining height by jumping between walls, re-attaching to the same wall if height is not gained, and allows any wall running if the cooldown since the last wall run have expired.
This sort of logic is where the start guards, like `OnEnterWallRun` and `OnExitWallRun` are important, to ensure that everything is always in a valid state for logic like to work.
![](/assets/project-mercury/CheckForWall.png)
The `CheckForWall` function is likewise important. Rather than simply ray casting left and right like many, many, many wallrunning implementations readily found, this function casts a set number of rays in a circle. This allows for wallrunning without requiring that the player's look direction be locked directly along the wall. This allows for the same fluidity of looking and aiming when on a wall as there is on the ground.
A raycast that collides a wall is only considered valid if the wall is close enough to vertical and if the player's velocity and acceleration are both sufficiently pointing into the wall. Of the valid hits in the circle, the closest is selected to represent the current wall.

#### Developer Extensibility
As I have just shown, the custom character movement component is structured such that adding new movement mechanics could be done very efficiently. A lot of movement mode implementation can follow the same basic pattern of
  - Adding a new enum variant to the movement mode enum.
  - Creating a `Can*` function (or for some actions, a `Try*` function is more appropriate), which checks the current state, and returns whether the state should be entered, as well as any information gathered necessary to carry out the state. For instance, the `CanWallRun` function has an out-parameter of type FHitResult, which will contain the most success raycast-to-wall hit after it concludes.
  - Adding a `Phys*` function.
  - Adding any state-tracking in `OnEnter*` and `OnExit*` functions.

##### Designer Friendly Programming
All of the low-level physics code I created for the movement component is endlessly tweakable and modifiable via UPROPERTYs, so that designer can independently tune in the feel of the component based on player feedback for tight iteration cycles.

##### Delegates and Points System
